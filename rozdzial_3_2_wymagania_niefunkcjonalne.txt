3.2. Wymagania niefunkcjonalne

Wymagania niefunkcjonalne określają jakościowe aspekty systemu, które nie dotyczą bezpośrednio jego funkcjonalności, ale są równie istotne dla sukcesu aplikacji. Pierwszym obszarem niefunkcjonalnym jest wydajność. System musi zapewniać responsywność interfejsu użytkownika, co oznacza że czas reakcji na akcje użytkownika powinien być możliwie krótki dla operacji lokalnych. Początkowe ładowanie aplikacji zostało zoptymalizowane poprzez wykorzystanie Vite jako bundlera, który implementuje natywny ES modules oraz hot module replacement, co drastycznie skraca czas deweloperski oraz rozruchu aplikacji.

Backend aplikacji wykorzystuje Node.js, który dzięki architekturze event-driven oraz non-blocking I/O jest w stanie obsłużyć wiele równoczesnych połączeń przy niewielkim zużyciu zasobów. Zapytania do bazy danych są konstruowane przy użyciu Prisma ORM, który automatycznie generuje optymalne zapytania SQL oraz wspiera eager loading relacji, eliminując problem N+1 queries. System wykorzystuje React Query (TanStack Query) do zarządzania stanem oraz automatycznego cache'owania odpowiedzi z API, co redukuje liczbę żądań HTTP oraz poprawia responsywność interfejsu.

Drugim kluczowym obszarem jest bezpieczeństwo. System chroni dane użytkowników przed nieautoryzowanym dostępem poprzez implementację wielowarstwowych mechanizmów zabezpieczeń. Wszystkie hasła użytkowników są hashowane algorytmem bcrypt z salt rounds wynoszącym 12, co zapewnia wysoki poziom oporności na ataki brute force. W środowisku deweloperskim komunikacja odbywa się poprzez protokół HTTP na localhost. W produkcji komunikacja powinna być wymuszana poprzez HTTPS, co szyfruje transmitowane dane oraz chroni przed atakami man-in-the-middle.

Tokeny JWT wykorzystywane do autoryzacji są podpisywane silnym kluczem przechowywanym w zmiennych środowiskowych (JWT_SECRET), a ich czas życia jest ograniczony do 15 minut dla access tokenów oraz 7 dni dla refresh tokenów. Refresh tokeny są przechowywane w bazie danych z możliwością rewokacji poprzez flagę revoked, co umożliwia administratorom wymuszenie wylogowania użytkownika w przypadku podejrzenia kompromitacji konta. System wykorzystuje bibliotekę Helmet do automatycznej konfiguracji zabezpieczających nagłówków HTTP, w tym Content Security Policy, X-Frame-Options oraz X-Content-Type-Options, co chroni przed typowymi atakami webowymi.

Wszystkie endpointy API są zabezpieczone przed atakami SQL injection poprzez wykorzystanie parametryzowanych zapytań oferowanych przez Prisma ORM, który automatycznie escapuje dane wejściowe użytkownika. Passport.js implementuje trzy strategie autentykacji: Local Strategy dla logowania email/hasło, JWT Strategy dla weryfikacji tokenów oraz Google Strategy dla OAuth 2.0. Middleware autentykacyjny weryfikuje tokeny przed przekazaniem żądań do kontrolerów, zwracając odpowiedź 401 Unauthorized w przypadku niepowodzenia.

Trzecim obszarem niefunkcjonalnym jest użyteczność oraz dostępność. Interfejs użytkownika został zaprojektowany jako intuicyjny, minimalizując krzywe uczenia dla nowych użytkowników. Nawigacja jest przejrzysta, a poszczególne sekcje aplikacji wyraźnie oznaczone zarówno ikonami z biblioteki Lucide React, jak i tekstowymi etykietami. System jest responsywny dzięki wykorzystaniu Tailwind CSS oraz flexbox layouts, co oznacza że interfejs dostosowuje się do różnych rozmiarów ekranów, od smartfonów po monitory desktopowe.

Aplikacja wykorzystuje semantyczny HTML oraz właściwe etykiety dla elementów formularzy, co wspiera technologie asystujące. Animacje są implementowane przy użyciu biblioteki Framer Motion, która zapewnia płynne przejścia bez blokowania głównego wątku przeglądarki. Komunikaty systemowe wykorzystują toast notifications lub inline error messages, które jasno informują użytkownika o problemach oraz sposobach ich rozwiązania. Interfejs unika żargonu technicznego, prezentując informacje w języku zrozumiałym dla przeciętnego użytkownika.

Czwartym obszarem jest skalowalność systemu. Architektura aplikacji umożliwia przyszłe skalowanie zarówno horyzontalne, jak i wertykalne. Backend jest zaprojektowany w sposób stateless, gdzie każde żądanie HTTP zawiera wszystkie niezbędne informacje w formie tokena JWT. Serwer nie przechowuje stanu sesji w pamięci, co umożliwia dystrybuowanie ruchu między wieloma instancjami backendu za pomocą load balancera bez konieczności sticky sessions. Prisma implementuje connection pooling, który efektywnie zarządza połączeniami do bazy danych, co jest kluczowe dla wydajności.

Kod aplikacji jest modularny, z wyraźnym podziałem na moduły funkcjonalne (auth, drill-practice, study, timeline, users, ai, battles, costumes). Każdy moduł zawiera własne routes oraz controllers, co ułatwia późniejsze refaktoryzacje oraz optymalizacje poszczególnych komponentów bez wpływu na pozostałe części systemu. Frontend wykorzystuje lazy loading komponentów poprzez React.lazy() oraz Suspense, co redukuje rozmiar początkowego bundle oraz skraca czas pierwszego ładowania.

Piątym obszarem niefunkcjonalnym jest niezawodność oraz obsługa błędów. Aplikacja implementuje mechanizmy obsługi błędów, które zapobiegają krytycznym awariom oraz zapewniają czytelne komunikaty dla użytkownika. Backend zawiera middleware do obsługi błędów, który catch'uje nieobsłużone wyjątki oraz zwraca strukturyzowane odpowiedzi JSON z kodem błędu oraz opisem problemu. Frontend wykorzystuje error boundaries w React do wyłapywania błędów renderowania oraz zapobiegania całkowitej awarii aplikacji.

System implementuje mechanizm health check poprzez endpoint /health, który zwraca status 200 OK wraz z timestampem, co umożliwia monitorowanie stanu aplikacji przez narzędzia zewnętrzne lub orchestratory kontenerów. Custom middleware logujący rejestruje wszystkie żądania HTTP do konsoli wraz z metodą, URL, kodem odpowiedzi oraz czasem przetwarzania, co ułatwia debugging oraz identyfikację problemów wydajnościowych. W przypadku błędów krytycznych, stack trace jest logowany do konsoli serwera.

Baza danych PostgreSQL jest uruchamiana w kontenerze Docker z konfiguracją wolumenu zapewniającego persystencję danych. Docker Compose definiuje serwis bazy danych, co upraszcza deployment oraz zapewnia spójność między środowiskami deweloperskimi. System może być rozbudowany o regularne backupy bazy danych poprzez pg_dump oraz przechowywanie kopii w zewnętrznej lokalizacji, co zapewnia możliwość odtworzenia danych w przypadku awarii.

Szóstym obszarem jest utrzymywalność kodu. Kod źródłowy aplikacji jest napisany w TypeScript zarówno dla backendu, jak i frontendu, co zapewnia type safety oraz wczesne wykrywanie błędów na etapie kompilacji. Projekt wykorzystuje ESLint do egzekwowania konwencji stylistic guidelines, co zapewnia spójność kodu oraz ułatwia czytanie przez wielu deweloperów. Funkcje oraz komponenty są organizowane zgodnie z zasadą Single Responsibility Principle, gdzie każdy moduł realizuje jedną wyraźnie określoną funkcjonalność.

Projekt zawiera podstawowy zestaw testów jednostkowych dla frontendu, zaimplementowanych przy użyciu Vitest oraz Testing Library. Package.json definiuje skrypty test, test:ui oraz test:coverage, które umożliwiają uruchamianie testów oraz generowanie raportów pokrycia kodu. Obecnie istnieje 5 plików testowych dla frontendu (basic.test.ts, localStorage.test.ts, utils.test.ts, Dashboard.test.tsx, DrillMode.test.tsx), podczas gdy backend nie posiada jeszcze testów automatycznych. System może być rozbudowany o testy integracyjne oraz end-to-end testy przy użyciu narzędzi takich jak Playwright lub Cypress.

Dokumentacja techniczna projektu zawiera plik README.md z instrukcjami instalacji oraz konfiguracji środowiska deweloperskiego. Schemat bazy danych jest zdefiniowany w pliku schema.prisma, który stanowi self-documenting source of truth dla struktury danych. Projekt nie implementuje obecnie CI/CD pipeline, ale jego modularnaarchitektura oraz skrypty w package.json ułatwiają integrację z narzędziami takimi jak GitHub Actions czy GitLab CI w przyszłości.
