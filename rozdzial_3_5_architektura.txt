3.5. Architektura wysokopoziomowa systemu

Architektura systemu HistoryMaster opiera się na wzorcu client-server z wyraźnym podziałem na warstwę prezentacji, warstwę logiki biznesowej oraz warstwę persystencji danych. Taki podział zgodny z zasadą separation of concerns umożliwia niezależny rozwój oraz testowanie poszczególnych warstw, a także ułatwia późniejszą rozbudowę systemu. Komunikacja między frontendem a backendem odbywa się poprzez RESTful API wykorzystujące protokół HTTP oraz format JSON do serializacji danych. Architektura ta zapewnia luźne powiązanie między komponentami, co zwiększa elastyczność oraz utrzymywalność systemu.

Warstwa prezentacji została zaimplementowana jako Single Page Application z wykorzystaniem biblioteki React w wersji 18.x. Aplikacja kliencka działa w przeglądarce użytkownika, a jej kod jest dostarczany poprzez serwer deweloperski Vite. Wykorzystanie React Router umożliwia implementację routingu po stronie klienta, co eliminuje konieczność przeładowywania całej strony podczas nawigacji między różnymi sekcjami aplikacji. Komponenty React są organizowane zgodnie z zasadą kompozycji, gdzie złożone interfejsy są budowane z mniejszych, reużywalnych komponentów funkcjonalnych. Zarządzanie stanem aplikacji odbywa się poprzez React Query (TanStack Query), które optymalizuje cachowanie danych oraz automatyczne odświeżanie przy zmianach.

Warstwa logiki biznesowej została zrealizowana w formie backendu Node.js wykorzystującego framework Express.js. Backend eksponuje zestaw endpointów RESTful API, które obsługują operacje CRUD na zasobach systemu. Architektura backendu jest zorganizowana w moduły odpowiadające poszczególnym obszarom funkcjonalnym aplikacji. System zawiera dziewięć głównych modułów: auth (autentykacja), drill-practice (quizy), study (fiszki), timeline (oś czasu), users (zarządzanie użytkownikami), ai (generowanie obrazów), battles (analiza bitew), costumes (stroje historyczne) oraz gamification (system progresji). Każdy moduł zawiera kontrolery odpowiedzialne za obsługę żądań HTTP oraz routes definiujące dostępne endpointy. Logika dostępu do danych jest realizowana bezpośrednio w kontrolerach poprzez Prisma Client.

Middleware stanowi istotny element architektury backendu, przechwytując żądania HTTP przed ich dotarciem do kontrolerów w celu wykonania operacji takich jak autentykacja, zabezpieczenia czy logowanie. System wykorzystuje bibliotekę Helmet, która automatycznie konfiguruje zabezpieczające nagłówki HTTP chroniące przed typowymi atakami webowymi. Custom middleware logujący rejestruje każde żądanie HTTP wraz z metodą, URL, kodem odpowiedzi oraz czasem przetwarzania, co ułatwia debugging oraz monitoring wydajności aplikacji.

Autentykacja i autoryzacja są realizowane przy użyciu biblioteki Passport.js implementującej trzy strategie. Local Strategy obsługuje logowanie użytkowników poprzez email oraz hasło, weryfikując poświadczenia z bazą danych. JWT Strategy waliduje tokeny JWT załączone w nagłówkach Authorization żądań do chronionych endpointów, ekstrahując informacje o użytkowniku oraz weryfikując ważność tokena. Google Strategy implementuje flow OAuth 2.0, umożliwiając użytkownikom logowanie przy użyciu konta Google. W przypadku niepowodzenia weryfikacji middleware zwraca odpowiedź 401 Unauthorized, zapobiegając dostępowi do chronionych zasobów.

Warstwa persystencji danych jest realizowana przez bazę danych PostgreSQL w wersji 16, która przechowuje wszystkie informacje systemowe, w tym dane użytkowników, pytania quizowe, fiszki oraz historię aktywności. Komunikacja z bazą danych odbywa się poprzez Prisma ORM w wersji 5.x, który zapewnia type-safe dostęp do danych oraz automatyczne generowanie kodu TypeScript na podstawie schematu bazy. Wykorzystanie ORM abstrakcjonuje szczegóły implementacyjne zapytań SQL, co upraszcza kod aplikacyjny oraz redukuje ryzyko błędów. Prisma automatycznie generuje migracje schematu bazy na podstawie zmian w pliku schema.prisma, co ułatwia zarządzanie ewolucją struktury danych. W środowisku deweloperskim baza danych jest uruchamiana w kontenerze Docker zdefiniowanym w pliku docker-compose.yml.

Integracja z zewnętrznymi serwisami została zrealizowana poprzez dedykowane adaptery enkapsulujące logikę komunikacji z API zewnętrznymi. Adapter Google Vertex AI (ImageGeneratorAdapter) jest odpowiedzialny za konstruowanie żądań do modelu Imagen 3.0, przesyłanie promptów oraz odbieranie wygenerowanych obrazów. Adapter implementuje autentykację poprzez Google Cloud Service Account oraz obsługuje konwersję obrazów z formatu base64 do URL. System przechowuje wygenerowane obrazy w tabeli GeneratedAsset, co umożliwia późniejsze cache'owanie oraz audyt wykorzystania API. Adapter Google OAuth jest zintegrowany poprzez bibliotekę passport-google-oauth20, obsługującą pełny flow autentykacji z przekierowaniami oraz wymianą tokenów.

System został zaprojektowany z myślą o konteneryzacji przy użyciu Docker. Baza danych PostgreSQL jest pakowana w kontener oparty na obrazie postgres:16-alpine, co zapewnia izolację oraz ułatwia deployment. Plik docker-compose.yml definiuje serwis bazy danych wraz z konfiguracją volumenu zapewniającego persystencję danych. Backend oraz frontend są uruchamiane w środowisku deweloperskim bezpośrednio na hoście, co przyspiesza iteracje podczas developmentu poprzez hot module replacement.

Bezpieczeństwo jest zintegrowane na wielu poziomach architektury. Hasła użytkowników nigdy nie są przechowywane w postaci jawnej, a jedynie ich hashe wygenerowane algorytmem bcrypt z salt округом 12. Tokeny JWT są podpisywane kluczem tajnym przechowywanym w zmiennych środowiskowych (JWT_SECRET), co zapobiega ich fałszowaniu. Access tokeny posiadają krótki czas życia (15 minut), a refresh tokeny przechowywane w bazie danych umożliwiają przedłużanie sesji bez ponownej autentykacji. System implementuje mechanizm rewokacji refresh tokenów poprzez flagę revoked w bazie danych. Konfiguracja CORS ogranicza dostęp do API tylko z dozwolonych originów, domyślnie http://localhost:5173 w środowisku deweloperskim.

Architektura systemu została zaprojektowana z uwzględnieniem przyszłej skalowalności. Backend Node.js jest stateless, co oznacza że każde żądanie zawiera wszystkie niezbędne informacje do jego obsługi w formie tokena JWT. Serwer nie przechowuje stanu sesji w pamięci, dzięki czemu możliwe jest horyzontalne skalowanie poprzez uruchamianie wielu instancji backendu za load balancerem. Wykorzystanie Prisma Connection Pooling zapewnia efektywne zarządzanie połączeniami do bazy danych, co jest kluczowe dla wydajności w przypadku większego obciążenia.

Monitoring oraz observability stanowią istotną część architektury. System implementuje podstawowe mechanizmy logowania zdarzeń aplikacyjnych do konsoli. Health check endpoint dostępny pod adresem /health umożliwia weryfikację stanu aplikacji, zwracając odpowiedź 200 OK wraz z timestampem. Custom middleware logujący rejestruje wszystkie żądania HTTP wraz z czasem ich przetwarzania, co pozwala na identyfikację potencjalnych wąskich gardeł wydajnościowych. W przypadku błędów serwer zwraca strukturyzowane odpowiedzi JSON zawierające kod błędu oraz opis problemu, co ułatwia debugging po stronie klienta.
